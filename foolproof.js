// Antipattern: Fool proof code;
// ------------------------------------------------------------------------------------
// Assumption: Idiots will pass anything to my function;
{
    const max = (...args) => {
        if (args.length !== 2) {
            throw new Error('Function expects two arguments');
        }
        const a = args.shift();
        if (typeof a !== 'number') {
            throw new Error('Unexpected type of first argument');
        }
        const b = args.shift();
        if (typeof b !== 'number') {
            throw new Error('Unexpected type of second argument');
        }
        return a > b ? a : b;
    }
    // Предполгаем, что юзер не прочитал документацию;
    // Пытаемся защититься от такого юзера и получаем когнитивно сложный код с кучей проверок.
}
// ------------------------------------------------------------------------------------
// Resolution: Simple and honest code;
// Вместо "защиты от дураков" лучше писать ясный, простой и понятный код, который:
// - Имеет четкий контракт (ожидает конкретные типы и количество аргументов).
// - Не пытается обрабатывать всё подряд (если передали не то — это ошибка вызывающей стороны).
// - Документирует свои требования (например, через JSDoc или TypeScript).
{
    /**
     * Возвращает наибольшее из двух чисел.
     * @param {number} a - Первое число.
     * @param {number} b - Второе число.
     * @returns {number} Наибольшее из a и b.
     */
    function max(a, b) {
        return a > b ? a : b;
    }
}
// Почему это лучше?
// - Четкий контракт – функция работает только с числами.
// - Простота – нет лишних проверок, код читается моментально.
// - Ошибки ловятся естественно – если передать не числа, JavaScript сам выдаст NaN или ошибку.
// ------------------------------------------------------------------------------------
