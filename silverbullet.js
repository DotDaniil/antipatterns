// Antipattern: Silver bullet
// ------------------------------------------------------------------------------------
// Example: when you know Array methods
{
    const name = 'Marcus Aurelius Antoninus Augustus';
    const spaceCount = name.split(' ').reduce((acc) => acc + 1, 0) - 1;
    console.log({ spaceCount });
}
// ------------------------------------------------------------------------------------
// Solution
{
    const name = 'Marcus Aurelius Antoninus Augustus';
    let spaceCount = 0;
    for (const char of name) {
        if (char === ' ') spaceCount++;
    }
    console.log({ spaceCount });
}
// ------------------------------------------------------------------------------------
// Example: when you know Promises
{
    const spaceCount = (str) => new Promise((resolve) => {
        let count = 0;
        for (const char of str) {
            if (char === ' ') count++;
        }
        resolve(count);
    });

    const name = 'Marcus Aurelius Antoninus Augustus';
    spaceCount(name).then((count) => console.log({ spaceCount: count }));
}
// ------------------------------------------------------------------------------------
// Solution
{
    const spaceCount = (str) => {
        let count = 0;
        for (const char of str) {
            if (char === ' ') count++;
        }
        return count;
    };

    const name = 'Marcus Aurelius Antoninus Augustus';
    console.log({ spaceCount: spaceCount(name) });
}
// ------------------------------------------------------------------------------------
// Conclusion:
// Не нужно
// ------------------------------------------------------------------------------------
// Использовать сложные конструкции для простых задач.
// Неправильно: split()+reduce() для подсчета пробелов.
// Почему: Избыточная сложность там, где достаточно простого цикла.
// Как надо: Использовать простой и понятный for...of или for.
// ------------------------------------------------------------------------------------
// Применять асинхронные механизмы для синхронных операций.
// Неправильно: Обертывать простой подсчет в Promise.
// Почему: Создает ненужную асинхронность, усложняет код.
// Как надо: Использовать синхронные функции для синхронных операций.
// ------------------------------------------------------------------------------------
// Использовать "модные" возможности языка без необходимости.
// Неправильно: Применять новые фичи (как reduce) только потому что они есть.
// Почему: Снижает читаемость без реальной выгоды.
// Как надо: Выбирать самый простой и понятный способ решения.
// ------------------------------------------------------------------------------------
// Правильный подход:
// KISS (Keep It Simple, Stupid).
// Использовать простейшее решение, которое решает задачу и учитывает затраты ресурсов процессора.
// Пример: Обычный цикл для подсчета символов.
// ------------------------------------------------------------------------------------
// Прямолинейность кода.
// Код должен явно и понятно отражать свою логику.
// Нужно стараться избегать излишней абстракции для простых операций.
// ------------------------------------------------------------------------------------
// Соответствие инструмента задаче.
// Синхронные операции - синхронные функции.
// Простые преобразования - простые методы.
// Сложную логику нужно оставлять для действительно сложных задач.